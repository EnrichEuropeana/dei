package pl.psnc.dei.service;

import io.netty.channel.ChannelOption;
import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.WriteTimeoutHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import pl.psnc.dei.model.DAO.DatasetsReposotory;
import pl.psnc.dei.model.DAO.ProjectsRepository;
import pl.psnc.dei.model.Dataset;
import pl.psnc.dei.model.Project;
import pl.psnc.dei.model.Record;
import pl.psnc.dei.model.Transcription;
import pl.psnc.dei.model.exception.TranscriptionPlatformException;
import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;
import reactor.netty.tcp.TcpClient;

import java.util.Arrays;
import java.util.List;

/**
 * Service responsible for communication with Transcription Platform.
 *
 * <p>
 * Created by pwozniak on 3/20/19
 */
@Service
public class TranscriptionPlatformService {

    private static final int READ_TIMEOUT_IN_SECONDS = 5;
    private static final int WRITE_TIMEOUT_IN_SECONDS = 5;
    private static final int CONNECTION_TIMEOUT_IN_SECONDS = 1;

    @Autowired
    private ProjectsRepository projectsRepository;

    @Autowired
    private DatasetsReposotory datasetsReposotory;

    private List<Project> availableProjects;
    private UrlBuilder urlBuilder;
    private WebClient webClient;

    public TranscriptionPlatformService(UrlBuilder urlBuilder,
                                        WebClient.Builder webClientBuilder) {
        this.urlBuilder = urlBuilder;
        configureWebClient(urlBuilder, webClientBuilder);
    }

    private void configureWebClient(UrlBuilder urlBuilder, WebClient.Builder webClientBuilder) {
        TcpClient tcpClient = TcpClient.create()
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, CONNECTION_TIMEOUT_IN_SECONDS * 1000)
                .doOnConnected(con -> con.addHandlerLast(new ReadTimeoutHandler(READ_TIMEOUT_IN_SECONDS))
                        .addHandlerLast(new WriteTimeoutHandler(WRITE_TIMEOUT_IN_SECONDS)));

        this.webClient = webClientBuilder
                .clientConnector(new ReactorClientHttpConnector(HttpClient.from(tcpClient)))
                .baseUrl(urlBuilder.getBaseUrl())
                .build();
    }

    public List<Project> getProjects() {
        if (!availableProjectInitialized()) {
            initAvailableProjects();
        }
        return availableProjects;
    }

    public void getDatasetsFor(Project project) {
        Dataset[] projectDatasets = this.webClient.get().uri(urlBuilder.urlForProjectDatasets(project)).retrieve().bodyToMono(Dataset[].class).block();

        for (Dataset projectDataset : projectDatasets) {
            projectDataset.setProject(project);
            project.getDatasets().add(projectDataset);
        }
    }

    public void getDatasetsFor(List<Project> projects) {
        for (Project project : projects) {
            getDatasetsFor(project);
        }
    }

    public void refreshAvailableProjects() {
        initAvailableProjects();
        getDatasetsFor(availableProjects);
        saveAvailableProjects();
    }

    /**
     * Reads all the transcriptions generated by the Transcription Platform for the given record
     *
     * @param record record that will be used for transcriptions fetching
     * @return list of all transcriptions for the given record
     * @throws TranscriptionPlatformException
     */
    public List<Transcription> fetchTranscriptionsFor(Record record) throws TranscriptionPlatformException {
        Transcription[] recordTranscriptions =
                this.webClient
                        .get()
                        .uri(urlBuilder.urlForRecord(record))
                        .retrieve()
                        .onStatus(HttpStatus::is5xxServerError, clientResponse -> Mono.error(new TranscriptionPlatformException()))
                        .bodyToMono(Transcription[].class)
                        .doOnError(cause -> {
                            if (cause instanceof TranscriptionPlatformException) {
                                throw new TranscriptionPlatformException("Error while communicating with Transcription Platform");
                            } else {
                                throw new TranscriptionPlatformException("Error while communicating with Transcription Platform", cause);
                            }
                        })
                        .block();
        return Arrays.asList(recordTranscriptions);
    }

    /**
     * Sends annotation url (generated by Annotations API) to the Transcription platform
     *
     * @param transcription
     * @param annotationUrl
     * @throws TranscriptionPlatformException
     */
    public void sendAnnotationUrl(Transcription transcription, String annotationUrl) throws TranscriptionPlatformException {

    }

    private boolean availableProjectInitialized() {
        return availableProjects != null;
    }

    private void initAvailableProjects() {
        Project[] projects = this.webClient.get().uri(urlBuilder.urlForAllProjects()).retrieve().bodyToMono(Project[].class).block();
        availableProjects = Arrays.asList(projects);
    }

    private void saveAvailableProjects() {
        for (Project project : availableProjects) {
            Project savedProject = projectsRepository.findByName(project.getName());
            if (savedProject == null) {
                savedProject = projectsRepository.save(project);
            }
            for (Dataset dataset : project.getDatasets()) {
                if (datasetsReposotory.findDatasetByDatasetId(dataset.getDatasetId()) == null) {
                    dataset.setProject(savedProject);
                    datasetsReposotory.save(dataset);
                }
            }
        }
    }

}
